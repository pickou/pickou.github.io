<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://pickou.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="https://pickou.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://pickou.github.io/" rel="alternate" type="text/html" /><updated>2017-12-26T23:15:40+08:00</updated><id>https://pickou.github.io/</id><title type="html">Yospace</title><subtitle>My intrest lies in Deep Learning and machine learning, which are highlighted in the blog. Other things like code style, git tools and languages(c, c++ and python) will also be coverd.</subtitle><entry><title type="html">Attention based text translation and document classification</title><link href="https://pickou.github.io/hierarchical-attention-networks/" rel="alternate" type="text/html" title="Attention based text translation and document classification" /><published>2017-12-24T00:00:00+08:00</published><updated>2017-12-24T00:00:00+08:00</updated><id>https://pickou.github.io/hierarchical-attention-networks</id><content type="html" xml:base="https://pickou.github.io/hierarchical-attention-networks/">&lt;p&gt;下图是attention机制在机器翻译上的表现，可以看到attention很好的解决了长句子级的机器翻译问题。&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/attention_model.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;
下面我们从文本翻译来讲解attention机制，传统的文本翻译一般是**encoder-decoder**的结构，如下图。现在将英文句子X翻译成中文句子Y，两个句子各自由不同的单词序列组成，表示如下,
$$
X=&amp;lt;x_1, x_2 ... x_m&amp;gt; \\
Y=&amp;lt;y_1,y_2 ...y_n&amp;gt;
$$

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/old_encoder-decoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

其中，encoder负责对输入的句子进行编码，将句子通过非线性变换转化为中间语义表示$C$,表示为\(C=E(x_1,x_2...x_m)\)。decoder根据X的中间语义\(C\)和之间的历史信息\(y_1, y_2...y_{i-1}\)
来生成i时刻的单词\(y_i\),表示为\(y_i = D(y_1,y_2...y_{i-1})\)。

那么attention机制是怎么一回事呢。先举个例子，假设X序列为**Jack love Rose**,Y序列为**杰克喜欢罗斯**。我们用分解encoder-decoder的过程，那么翻译的过程就是依次生成**杰克**、**喜欢**、**罗斯**,表示为

$$
y_1 = D(C) \\
y_2 = D(C,y_1) \\
y_3 = D(C,y_1,y_2)
$$

传统的语义表示方法的局限就体现出来了，在生成目标句子的单词的时候，无论是$y_1$,$y_2$还是$y_3$，都使用的语义编码C,没有变化,换句话来说就是句子X中的任意单词对于生成目标单词$y_i$的
影响都是一样的，这明显是不科学的。attention就是为了解决这个不合理的地方，比如在翻译出`喜欢`这个词的时候，`love`的贡献率应该更大，而`Jack`和`Rose`就显得不那么重要了。
注意力机制要体现英文单词对于翻译当前中文单词的不同影响程度,类似于给出一个概率分布值，比如在翻译出喜欢这个词的时候,表示为$(Jack,0.3)(love,0.5)(Rose,0.2)$。

引入注意力机制之后，目标句子中的每个单词都会学习对应源句子中每个单词的注意力分配概率的信息。这就相当于在生成每个单词$y_i$的时候，都会根据$y_1,y_2...y_{i-1}$来生成新的变化的$c_i$,
模型结构如下图，翻译的过程就变成了下面这个过程

$$
y_1 = D(C_1) \\
y_2 = D(C_2,y_1) \\
y_3 = D(C_3,y_1,y_2)
$$

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/am-encoder-decoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

对于上面那个例子，其对应的翻译过程可能如下,其中$F$函数是encoder对英文单词的变换函数，如果是RNN模型，那么$F$对应的结果是某个时刻隐层节点的状态值，
$G$函数代表encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般是对构成元素加权求和。

$$
c_{杰克} =G(0.6*F('Jack'),0.2*F('love),0.2*F('Rose')) \\
c_{喜欢} =G(0.2*F('Jack'),0.7*F('love),0.1*F('Rose')) \\
c_{罗斯} =G(0.2*F('Jack'),0.3*F('love),0.5*F('Rose'))
$$

以RNN作为encoder和decoder,那么传统的文本翻译的过程就如下图，经过一个RNN的encoder将一句话的语义全部放在了一个矩阵C中,然后再通过decoder翻译出来,这样看来就更能看出整个模型的缺点了,
这在长句子翻译上的表现差就很容易解释了，因为长句子蕴含的信息量更大，但仍旧只是把句子的语义映射到一个固定大小的矩阵中去，这没办法完整地表示整个句子的语义

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/RNN-encoder-decoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

attention的结构，就是将之前的隐层单元输出都收集起来，对这些输出做了个加权求和，这个权值体现了源句子中每个词对于当前需要翻译的词的贡献，结构如下图，

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/am-rnn-encoder-decoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

总结下，attention机制，就像人在足球比赛，每个时刻，注意力都可能放到不同的人身上，C罗带球了，你可能关注点放到了C罗身上，梅西射门了,那么你肯定更关注这个球进没进，梅西脚下动作是什么，
相比之下，其他后卫的跑位，掩护可能都没有这些东西更吸引你关注。这个关注就是attention机制，相当于你大脑给这个事件更大的权重。又比如，你读一本小说，需要读懂当前情节，就需要之前的
铺垫和背景知识，但是不是所有的背景知识对于理解当前情节都是很重要的，这个重要程度就是attention机制。简而言之，**attention机制**解决了之前的模型**抓不住重点**的问题.


###Attention for document classification
hierarchical attention network描述了**文档的结构**，文档是由句子构成的，句子是由单词构成的。又加入了**两个层次的attention机制**，一个是句子级的,一个是单词级的，
给出了单词和句子对于整个信息的不同贡献程度。

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/HAN.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

一个文档有$L$个句子$s_i$，每个句子有$T_i$个词，$w_{it}$表示第i句话中的第t个词

* word encoder

一开始，需要通过embedding矩阵$W_e$转化为对应的embedding,然后通过双向的GRU，获得前向的hidden state，和反向的hidden state,组合成为一个新的$h_{it}$,
这样都把这个词的语义用周围的词表示出来了。

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/word-encoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

* word attention

不是所有的词都是一句话的重点，所以，引入了attention的机制。先让$`h_it`$通过一个单层的MLP,得到$`h_{it}`$的隐层表示$`u_{it}`$,
然后通过计算$`u_{it}`$和$`u_w`$之间的相似度来衡量这个词对于句子语义的重要程度。$`u_w`$随机初始化的，通过训练学习得到。通过
softmax,最后对所有单词加权和得到句子的表示$`s_i`$。

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/word_attention.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

* sentence encoder

不是所有的句子都是一个文档的重点，所以，在句子级也引入了attention机制。同理，对于每个句子$`s_i`$,前向和后向的hidden units组合成一个新的$`h_{it}`$,
然后通过同样的方式引入attention,最后加权求和得到整个文档的语义表示$`v`$。

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/sentence-encoder.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

* sentence attention

&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/attention/sentence-attention.png&quot; /&gt;&lt;/a&gt;
&lt;figure&gt;

### Reference

* http://www.cs.cmu.edu/~./hovy/papers/16HLT-hierarchical-attention-networks.pdf
* https://github.com/richliao/textClassifier
* https://github.com/ematvey/hierarchical-attention-networks
* http://blog.csdn.net/malefactor/article/details/50550211
&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/figure&gt;</content><category term="attention" /><category term="document classification" /><category term="DL" /><summary type="html">hierarchical attention networks for document classification</summary></entry><entry><title type="html">recurrent neural networks</title><link href="https://pickou.github.io/rnn-networks/" rel="alternate" type="text/html" title="recurrent neural networks" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>https://pickou.github.io/rnn-networks</id><content type="html" xml:base="https://pickou.github.io/rnn-networks/">&lt;p&gt;先占个位置，后续添加&lt;/p&gt;</content><category term="rnn" /><category term="lstm" /><category term="DL" /><summary type="html">basic knwoledge about rnn and lstm</summary></entry><entry><title type="html">recommender system</title><link href="https://pickou.github.io/recommender/" rel="alternate" type="text/html" title="recommender system" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>https://pickou.github.io/recommender</id><content type="html" xml:base="https://pickou.github.io/recommender/">&lt;p&gt;先占个位置，后续添加, 仅仅&lt;strong&gt;测试一下子&lt;/strong&gt;， 看看这个语法还能行不&lt;/p&gt;

&lt;h3 id=&quot;搞得我头大了&quot;&gt;搞得我头大了&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;嘛单的&lt;/li&gt;
  &lt;li&gt;这是神码&lt;/li&gt;
&lt;/ul&gt;</content><category term="recommender" /><summary type="html">recommender system knwoledge</summary></entry><entry><title type="html">imbalanced machine learning</title><link href="https://pickou.github.io/imblanced-learning/" rel="alternate" type="text/html" title="imbalanced machine learning" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>https://pickou.github.io/imblanced-learning</id><content type="html" xml:base="https://pickou.github.io/imblanced-learning/">&lt;p&gt;先占个位置，后续添加&lt;/p&gt;</content><category term="imbalance data" /><summary type="html">talk about imbalanced machine learning</summary></entry><entry><title type="html">gitlab workflow</title><link href="https://pickou.github.io/gitlab-usage/" rel="alternate" type="text/html" title="gitlab workflow" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>https://pickou.github.io/gitlab-usage</id><content type="html" xml:base="https://pickou.github.io/gitlab-usage/">&lt;p&gt;gitlab作为一个协同工作的代码管理工具，使用起来很方便，能大大提高生产效率。&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/gitlab.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;p&gt;git的工作流主要维护本地仓库的三棵树，分别是&lt;strong&gt;工作目录&lt;/strong&gt;，包含了实际的文件；&lt;strong&gt;暂存区(Index)&lt;/strong&gt;，
相当于一个缓冲区，保存临时改动；&lt;strong&gt;HEAD&lt;/strong&gt;,指向最后一次提交的结果。&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/gitworkflow.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;1-easy-workflow&quot;&gt;1. easy workflow&lt;/h2&gt;
&lt;p&gt;take demo.cpp for example&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add demo.cpp&lt;/code&gt; demo.cpp被添加到暂存区&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;demo cpp&quot;&lt;/code&gt; 提交改动到&lt;strong&gt;HEAD&lt;/strong&gt;,但还没有提交到远程分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull origin branch-name&lt;/code&gt; 从远程分支上pull到本地，更新本地分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin branch-name&lt;/code&gt; 提交改动到远程分支branch-name上&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-branch&quot;&gt;2. branch&lt;/h2&gt;
&lt;p&gt;一般在创建一个repository之后，会有一个默认的分支master。现在，在本地建立一个新的分支&lt;code class=&quot;highlighter-rouge&quot;&gt;feature_x&lt;/code&gt;,
使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b feature_x&lt;/code&gt;，就在本地新建了一个分支，并同时切换到该分支上，这个分支相当于
另外一个工作区。使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout master&lt;/code&gt;就切换回master了。&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin feature_x&lt;/code&gt;本地新建
的分支就被推送到远程，远程多了一个分支&lt;code class=&quot;highlighter-rouge&quot;&gt;feature_x&lt;/code&gt;。要删除分支，使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch -d feature_x&lt;/code&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/branch.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;3-merge&quot;&gt;3. merge&lt;/h2&gt;
&lt;p&gt;在工业生产中，每个人会在一个对应的分支上开发自己的feature,完成开发之后提交&lt;strong&gt;MR&lt;/strong&gt;,然后通过review,和CI,
最终merge到master上。这样保证了项目的质量，同时提高工作效率。&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge feature_x&lt;/code&gt;，提交了
&lt;code class=&quot;highlighter-rouge&quot;&gt;feature_x&lt;/code&gt;和master的MR。&lt;/p&gt;

&lt;p&gt;当你在merge或者是pull的时候可能会出现conflicts，那么你需要先修改好这些冲突，
然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;添加修改好的文件，再进行后续的步骤。&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/merge.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;4-git-rebase&quot;&gt;4. git rebase&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;主要作用是将一个分支的修改合并到当前的分支，下面以一个例子来讲解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在有一个远程分支origin,已经有了两个commits，然后基于origin分支新建一个mywork分支&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/w1.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;ul&gt;
  &lt;li&gt;你在mywork分支上有了两个commits,你的同事在origin上也提交了两个commits，两个分支各自都前进了,
那么就产生了分叉&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/w2.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;ul&gt;
  &lt;li&gt;你在提交MR之前会先会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;更新本地分支，那么两个分支就会产生merge，看起来就是这样的&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/w3.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;ul&gt;
  &lt;li&gt;如果你想要mywork分支像没有经过合并一样，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;,这样会把mywork分支中的commits临时
保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;.git/rebase&lt;/code&gt;中，然后更新mywork为最新的origin分支，接着再把这些临时保存的修改应用到mywork上,
这样，看起来就跟没有合并一样，结构更为清爽，便于repository的管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/w4.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;ul&gt;
  &lt;li&gt;当mywork分支更新之后，之前的commits就会被丢掉，垃圾回收机制就会把这些没有用的commits给删除掉&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/w5.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;的过程中出现了conflicts，那么可以先解决玩冲突，然后使用git add添加修改，接着使用
&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase --continue&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-conflicts&quot;&gt;5. conflicts&lt;/h2&gt;
&lt;p&gt;多人协作的时候,很容易产生conflicts,这时候需要我们先在本地解决好冲突，然后再进行后面的步骤。冲突表现为
下图这样，在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;之间是你当前的修改,后面那部分是别人的修改或者是你之前的修改。如果两个工作都需要，
那么把所有的非代码部分去掉就可以了，如果只需要其中一个，那就保留其中一个。&lt;/p&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/conflicts.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;6-other-commands&quot;&gt;6. other commands&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash&lt;/code&gt; 用作你有一些修改，但是又不想提交这些修改，同时你又要回到一个干净的工作环境。这个命令
就会把你在工作环境中和Index下的修改放到一个缓冲区去，然后把工作环境revert到最近的一个commits(HEAD)。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash pop&lt;/code&gt; 弹出之前保存的修改&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 查看git的日志，所有提交的commits。可以按照树形显示分支，&lt;code class=&quot;highlighter-rouge&quot;&gt;git log --graph --oneline --decorate --all&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;a&gt;&lt;img src=&quot;https://pickou.github.io/pics/git_log.png&quot; /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;reference&quot;&gt;Reference&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;http://rogerdudler.github.io/git-guide/index.zh.html&lt;/li&gt;
  &lt;li&gt;https://team-coder.com/avoid-merge-conflicts/&lt;/li&gt;
  &lt;li&gt;http://blog.csdn.net/hudashi/article/details/7664631/&lt;/li&gt;
  &lt;li&gt;https://git-scm.com/docs/git-rebase&lt;/li&gt;
  &lt;li&gt;https://team-coder.com/from-git-flow-to-trunk-based-development/&lt;/li&gt;
&lt;/ul&gt;</content><category term="gitlab" /><category term="tools" /><summary type="html">gitlab, code manage tool for cooperation</summary></entry></feed>
